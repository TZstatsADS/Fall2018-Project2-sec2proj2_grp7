add_polylines(lat = pldf[,1], lon = pldf[,2])
google_map(key = key, data = tram_stops) %>%
add_markers(lat = "stop_lat", lon = "stop_lon", info_window = "stop_name")
## using marker icons
iconUrl <- paste0("https://developers.google.com/maps/documentation/",
"javascript/examples/full/images/beachflag.png")
tram_stops$icon <- iconUrl
google_map(key = key, data = tram_stops) %>%
add_markers(lat = "stop_lat", lon = "stop_lon", marker_icon = "icon")
View(X)
fit1 <- lm(bwt~age+lwt+factor(race)+smoke+ptl+ht+ui+ftv,data=birthwt)
summary(fit1)
data("birthwt")
data <- birthwt
View(birthwt)
View(data)
brthwt.df <- birthwt
race.decode <- function(x){
return(ifelse(x!=1,0,x))
}
birthwt$race <- apply(birthwt$race,1,race.decode)
help(apply)
birthwt$race <- apply(birthwt,"race",race.decode)
help(vapply)
birthwt$race <- vapply(birthwt$race,race.decode)
birthwt$race <- sapply(birthwt$race,race.decode)
View(birthwt)
summary(fit1)
fit1 <- lm(bwt~age+lwt+race+smoke+ptl+ht+ui+ftv,data=birthwt)
summary(fit1)
ev <- eigen(cor(fit1$model))
# Eigenvalues of correlation matrix of X
ev$values
max(ev$values)/min(ev$values)
# Evaluate Collinearity
vif(fit1) # variance inflation factors
View(birthwt)
X <- as.matrix(birthwt[,2:9])
Y <- as.matrix(birthwt[,10])
cv_ridge_fit <- cv.glmnet(X, Y, alpha = 0, lambda = lambdas)
plot(cv_ridge_fit)
fit2 <- cv_ridge_fit$glmnet.fit
summary(fit2)
opt_lambda <- cv_ridge_fit$lambda.min
Y_predicted_ridge <- predict(fit2, s = opt_lambda, newx = X)
# RSS
rss_ridge <- sum((Y-Y_predicted_ridge)^2)
rss_ols <- sum(fit1$residuals^2)
# R squared
R_sq_ols <- summary(fit1)$r.squared
R_sq_ridge <- 1 - rss_ridge/sum((Y-mean(Y))^2)
# Adjust R squared
adj_r_sq_ols <- summary(fit1)$adj.r.squared
adj_coef <- (nrow(Y)-1)/(nrow(Y)-ncol(X)-1)
adj_r_sq_ridge <- 1-adj_coef*rss_ridge/sum((Y-mean(Y))^2)
list(RSS=c(rss_ols,rss_ridge),Rsquared=c(R_sq_ols,R_sq_ridge),AdjustedRsquared=c(adj_r_sq_ols,adj_r_sq_ridge))
cv_lasso_fit <- cv.glmnet(X, Y, alpha = 1, lambda = lambdas)
plot(cv_lasso_fit)
fit3 <- cv_lasso_fit$glmnet.fit
plot(fit3)
summary(fit3)
opt_lambda <- cv_lasso_fit$lambda.min
Y_predicted_lasso <- predict(fit3, s = opt_lambda, newx = X)
# RSS
rss_lasso <- sum((Y-Y_predicted_lasso)^2)
opt_lambda <- cv_lasso_fit$lambda.min
Y_predicted_lasso <- predict(fit3, s = opt_lambda, newx = X)
lasso.coef  <- predict(fit3, type = 'coefficients', s = opt_lambda)
lasso.coef  <- predict(fit3, type = 'coefficients', s = opt_lambda)[1:6,]
lasso.coef
lasso.coef  <- predict(fit3, type = 'coefficients', s = opt_lambda)[1:8,]
lasso.coef
rss_lasso <- sum((Y-Y_predicted_lasso)^2)
R_sq_lasso <- 1 - rss_lasso/sum((Y-mean(Y))^2)
ridge.coef <- predict(ridge.mod, type = "coefficients", s = bestlam)[1:8,]
ridge.coef <- predict(fit2, type = "coefficients", s = bestlam)[1:8,]
opt_lambda <- cv_ridge_fit$lambda.min
Y_predicted_ridge <- predict(fit2, s = opt_lambda, newx = X)
ridge.coef <- predict(fit2, type = "coefficients", s = opt_lambda)[1:8,]
print(ridge.coef)
fit4 <- stepAIC(fit1, direction = "both", trace = FALSE)
summary(fit4)
raw_data <- read.csv("fraud_data.csv",header = T)
library(car)
library(MASS)
library(glmnet)
data("birthwt")
race.decode <- function(x){
return(ifelse(x!=1,1,0))
}
birthwt$race <- sapply(birthwt$race,race.decode)
fit1 <- lm(bwt~age+lwt+race+smoke+ptl+ht+ui+ftv,data=birthwt)
summary(fit1)
X <- as.matrix(birthwt[,2:9])
ev <- eigen(cor(X))
# Eigenvalues of correlation matrix of X
# condition number >30 indicate multicollinearity
max(ev$values)/min(ev$values)
vif(fit1) # variance inflation factors
# VIF > 10 indicates multicollinearity
lambdas <- 10^seq(3, -3, by = -.1)
Y <- as.matrix(birthwt[,10])
cv_ridge_fit <- cv.glmnet(X, Y, alpha = 0, lambda = lambdas)
plot(cv_ridge_fit)
fit2 <- cv_ridge_fit$glmnet.fit
plot(fit2,xvar="lambda")
lambdas <- 10^seq(4, -2, by = -.1)
Y <- as.matrix(birthwt[,10])
cv_ridge_fit <- cv.glmnet(X, Y, alpha = 0, lambda = lambdas)
plot(cv_ridge_fit)
fit2 <- cv_ridge_fit$glmnet.fit
plot(fit2,xvar="lambda")
Y <- as.matrix(birthwt[,10])
cv_ridge_fit <- cv.glmnet(X, Y, alpha = 0)
plot(cv_ridge_fit)
fit2 <- cv_ridge_fit$glmnet.fit
plot(fit2,xvar="lambda")
# coefficients
opt_lambda <- cv_ridge_fit$lambda.min
Y_predicted_ridge <- predict(fit2, s = opt_lambda, newx = X)
ridge.coef <- predict(fit2, type = "coefficients", s = opt_lambda)[1:8,]
print(ridge.coef)
# RSS
rss_ridge <- sum((Y-Y_predicted_ridge)^2)
rss_ols <- sum(fit1$residuals^2)
# R squared
R_sq_ols <- summary(fit1)$r.squared
R_sq_ridge <- 1 - rss_ridge/sum((Y-mean(Y))^2)
# Adjust R squared
adj_r_sq_ols <- summary(fit1)$adj.r.squared
adj_coef <- (nrow(Y)-1)/(nrow(Y)-ncol(X)-1)
adj_r_sq_ridge <- 1-adj_coef*rss_ridge/sum((Y-mean(Y))^2)
print(matrix(c(rss_ols,rss_ridge,R_sq_ols,
R_sq_ridge,adj_r_sq_ols,adj_r_sq_ridge),
nrow = 3, byrow=T, dimnames =
list(rows=c("RSS","R squared","Adjusted R squared"),
cols=c("OLS","Ridge"))))
cv_lasso_fit <- cv.glmnet(X, Y, alpha = 1)
plot(cv_lasso_fit)
fit3 <- cv_lasso_fit$glmnet.fit
plot(fit3)
opt_lambda <- cv_lasso_fit$lambda.min
Y_predicted_lasso <- predict(fit3, s = opt_lambda, newx = X)
# Coefficients
lasso.coef  <- predict(fit3, type = 'coefficients', s = opt_lambda)[1:8,]
print(lasso.coef)
fit4 <- stepAIC(fit1, direction = "backward", trace = FALSE)
summary(fit4)
# RSS
rss_lasso <- sum((Y-Y_predicted_lasso)^2)
rss_stepwise <- sum(fit4$residuals^2)
# R squared
R_sq_lasso <- 1 - rss_lasso/sum((Y-mean(Y))^2)
R_sq_stepwise <- summary(fit4)$r.squared
print(matrix(c(rss_lasso,rss_stepwise,R_sq_lasso,
R_sq_stepwise),nrow = 2, byrow=T, dimnames =
list(rows=c("RSS","R squared"),
cols=c("Lasso","Stepwise(backward)"))))
opt_lambda <- cv_ridge_fit$lambda.min
Y_predicted_ridge <- predict(fit2, s = opt_lambda, newx = X)
ridge.coef <- predict(fit2, type = "coefficients", s = opt_lambda)[1:9,]
print(ridge.coef)
opt_lambda <- cv_lasso_fit$lambda.min
Y_predicted_lasso <- predict(fit3, s = opt_lambda, newx = X)
# Coefficients
lasso.coef  <- predict(fit3, type = 'coefficients', s = opt_lambda)[1:9,]
print(lasso.coef)
Y <- data.matrix(birthwt[,10])
cv_ridge_fit <- cv.glmnet(X, Y, alpha = 0)
plot(cv_ridge_fit)
fit2 <- cv_ridge_fit$glmnet.fit
plot(fit2,xvar="lambda")
opt_lambda <- cv_ridge_fit$lambda.min
Y_predicted_ridge <- predict(fit2, s = opt_lambda, newx = X)
ridge.coef <- predict(fit2, type = "coefficients", s = opt_lambda)[1:9,]
print(ridge.coef)
# RSS
rss_ridge <- sum((Y-Y_predicted_ridge)^2)
rss_ols <- sum(fit1$residuals^2)
# R squared
R_sq_ols <- summary(fit1)$r.squared
R_sq_ridge <- 1 - rss_ridge/sum((Y-mean(Y))^2)
# Adjust R squared
adj_r_sq_ols <- summary(fit1)$adj.r.squared
adj_coef <- (nrow(Y)-1)/(nrow(Y)-ncol(X)-1)
adj_r_sq_ridge <- 1-adj_coef*rss_ridge/sum((Y-mean(Y))^2)
print(matrix(c(rss_ols,rss_ridge,R_sq_ols,
R_sq_ridge,adj_r_sq_ols,adj_r_sq_ridge),
nrow = 3, byrow=T, dimnames =
list(rows=c("RSS","R squared","Adjusted R squared"),
cols=c("OLS","Ridge"))))
opt_lambda <- cv_lasso_fit$lambda.min
Y_predicted_lasso <- predict(fit3, s = opt_lambda, newx = X)
# Coefficients
lasso.coef  <- predict(fit3, type = 'coefficients', s = opt_lambda)[1:9,]
print(lasso.coef)
library(shiny)
library(plotly)
ui <- fluidPage(
plotlyOutput("plot"),
verbatimTextOutput("click")
)
server <- function(input, output, session) {
output$plot <- renderPlotly({
# specify some map projection/options
g <- list(
scope = 'usa',
projection = list(type = 'albers usa'),
lakecolor = toRGB('white')
)
plot_ly(z = state.area, text = state.name, locations = state.abb,
type = 'choropleth', locationmode = 'USA-states') %>%
layout(geo = g)
})
output$click <- renderPrint({
d <- event_data("plotly_click")
if (is.null(d)) "Click on a state to view event data" else d
})
}
shinyApp(ui, server)
library(shinydashboard)
library(shiny)
library(dplyr)
library(leaflet)
library(DT)
library(data.table)
library(ggmap)
library(googleVis)
library(tidyr)
hospital_info <- read.csv("hospital_2016.csv")
setwd("~/Downloads/GR5243/Rshiny/app")
hospital_info <- read.csv("hospital_2016.csv")
hospital_address <- hospital_info %>% select(Hospital.Name,State,Full,lat,lon) %>% unque()
hospital_address <- hospital_info %>% select(Hospital.Name,State,Full,lat,lon) %>% unique()
ui <- fluidPage(
leafletOutput("mymap")
)
server <- function(input, output, session) {
output$mymap <- renderLeaflet({
leaflet() %>%addTiles() %>%
addMarkers(lat=hospital_address$lat,lng=hospital_address$lon,popup=as.character(hospital_address$Hospital.Name)
)
})
}
shinyApp(ui,server)
server <- function(input, output, session) {
output$mymap <- renderLeaflet({
leaflet() %>%addTiles() %>%
addMarkers(lat=hospital_address$lat,lng=hospital_address$lon,popup=as.character(hospital_address$State)
)
})
}
shinyApp(ui,server)
setwd("~/Documents/GitHub/Fall2018-Project2-sec2_proj2_grp7/output/data_cleaning_code")
hospital_info <- read.csv("../merged_2016.csv")
hospital_address <- hospital_info %>%
select(Hospital.Name,Provider.ID, Address, City, State, ZIP.Code) %>%
distinct()
hospital_address <- hospital_address %>% mutate(Full=paste(Address,City,State,ZIP.Code,"USA",sep=", "))
for(i in 1:nrow(hospital_address))
{
#print(i)
result <- geocode(hospital_address$Full[i], output = "latlon", source = "dsk",messaging = FALSE)
hospital_address$lon[i] <- as.numeric(result[1])
hospital_address$lat[i] <- as.numeric(result[2])
}
setwd("~/Downloads/GR5243/Rshiny/app")
ui <- fluidPage(
leafletOutput("mymap")
)
top  <- 49.3457868 # north lat
left <- -124.7844079 # west long
right <- -66.9513812 # east long
bottom <-  24.7433195 # south lat
flaggedError <- c()
for(i in 1:nrow(hospital_address)) {
if(bottom <= hospital_address[i]$lat <= top & left <= hospital_address[i]$lon <= right) {
return()
}
else {
flaggedError <- c(flaggedError,i)
}
}
flaggedError <- c()
for(i in 1:nrow(hospital_address)) {
if(bottom <= hospital_address[i]$lat & hospital_address[i]$lat <= top &
left <= hospital_address[i]$lon & hospital_address[i]$lon<= right) {
return()
}
else {
flaggedError <- c(flaggedError,i)
}
}
bottom <= hospital_address[1]$lat & hospital_address[1]$lat <= top &
left <= hospital_address[1]$lon & hospital_address[1]$lon<= right
bottom <= hospital_address[1]$lat
bottom <= hospital_address$lat[1]
for(i in 1:nrow(hospital_address)) {
if(bottom <= hospital_address$lat[i] & hospital_address$lat[i] <= top &
left <= hospital_address$lon[i] & hospital_address$lon[i]<= right) {
return()
}
else {
flaggedError <- c(flaggedError,i)
}
}
head(flaggedError)
flaggedError <- c()
for(i in 1:nrow(hospital_address)) {
if(!(bottom <= hospital_address$lat[i] & hospital_address$lat[i] <= top &
left <= hospital_address$lon[i] & hospital_address$lon[i]<= right)) {
flaggedError <- c(flaggedError,i)
}
}
flaggedError <- c()
for(i in 1:nrow(hospital_address)) {
if(bottom <= hospital_address$lat[i] & hospital_address$lat[i] <= top &
left <= hospital_address$lon[i] & hospital_address$lon[i]<= right) {
flaggedError <- c(flaggedError)
}else{
flaggedError <- c(flaggedError,i)
}
}
bottom <= hospital_address$lat[1] & hospital_address$lat[1] <= top
flaggedError <- c()
for(i in 1:nrow(hospital_address)) {
if(bottom <= hospital_address$lat[i] & hospital_address$lat[i] <= top & left <= hospital_address$lon[i] & hospital_address$lon[i]<= right) {
flaggedError <- c(flaggedError)
}else{
flaggedError <- c(flaggedError,i)
}
}
bottom <= hospital_address$lat[1] & hospital_address$lat[1] <= top & left <= hospital_address$lon[1] & hospital_address$lon[1]<= right
for(i in 1:nrow(hospital_address)) {
if((bottom <= hospital_address$lat[i]) & (hospital_address$lat[i] <= top) & (left <= hospital_address$lon[i]) & (hospital_address$lon[i]<= right)) {
flaggedError <- c(flaggedError)
}else{
flaggedError <- c(flaggedError,i)
}
}
flaggedError <- c()
for(i in 1:nrow(hospital_address)) {
if(hospital_address$lon >= right|hospital_address$lon <= left) {
flaggedError <- c(flaggedError)
}else{
flaggedError <- c(flaggedError,i)
}
}
warnings()
flaggedError <- c()
for(i in 1:nrow(hospital_address)) {
if(hospital_address$lon[i] >= right|hospital_address$lon[i] <= left) {
flaggedError <- c(flaggedError)
}else{
flaggedError <- c(flaggedError,i)
}
}
View(hospital_address)
is.na(hospital_address$lon)
sum(is.na(hospital_address$lon))
for (i in which(is.na(hospital_address$lon))) {
result <- geocode(paste(hospital_address$City[i],hospital_address$State[i],hospital_address$ZIP.Code[i],sep = ","), output = "latlon", source = "dsk")
hospital_address$lon[i] <- as.numeric(result[1])
hospital_address$lat[i] <- as.numeric(result[2])
}
for (i in which(is.na(hospital_address$lon))) {
result <- geocode(paste(hospital_address$City[i],hospital_address$State[i],sep = ","), output = "latlon", source = "dsk")
hospital_address$lon[i] <- as.numeric(result[1])
hospital_address$lat[i] <- as.numeric(result[2])
}
which(is.na(hospital_address$lon))
top  <- 49.3457868 # north lat
left <- -124.7844079 # west long
right <- -66.9513812 # east long
bottom <-  24.7433195 # south lat
flaggedError <- c()
for(i in 1:nrow(hospital_address)) {
if(hospital_address$lon[i] >= right|hospital_address$lon[i] <= left) {
flaggedError <- c(flaggedError)
}else{
flaggedError <- c(flaggedError,i)
}
}
top  <- 72 # north lat
left <- -144 # west long
right <- -66.9513812 # east long
bottom <-  18 # south lat
flaggedError <- c()
for(i in 1:nrow(hospital_address)) {
if(hospital_address$lon[i] >= right|hospital_address$lon[i] <= left) {
flaggedError <- c(flaggedError)
}else{
flaggedError <- c(flaggedError,i)
}
}
flaggedError <- c()
for(i in 1:nrow(hospital_address)) {
if(hospital_address$lon[i] <= right && right|hospital_address$lon[i] >= left) {
flaggedError <- c(flaggedError)
}else{
flaggedError <- c(flaggedError,i)
}
}
flaggedError <- c()
for(i in 1:nrow(hospital_address)) {
if(hospital_address$lon[i] <= right && hospital_address$lon[i] >= left) {
flaggedError <- c(flaggedError)
}else{
flaggedError <- c(flaggedError,i)
}
}
flaggedError <- c()
for(i in 1:nrow(hospital_address)) {
if(hospital_address$lon[i] <= right && hospital_address$lon[i] >= left
&& hospital_address$lat[i] <= top && hospital_address$lat[i] >= bottom) {
flaggedError <- c(flaggedError)
}else{
flaggedError <- c(flaggedError,i)
}
}
for (i in which(hospital_address$State=="NJ")) {
result <- geocode(paste(hospital_address$Address[i] , hospital_address$City[i],"New Jersey USA"), output = "latlon", source = "dsk")
hospital_address$lon[i] <- as.numeric(result[1])
hospital_address$lat[i] <- as.numeric(result[2])
}
for (i in which(hospital_address$State=="MA")) {
result <- geocode(paste(hospital_address$Address[i] , hospital_address$City[i],"Massachusetts USA"), output = "latlon", source = "dsk")
hospital_address$lon[i] <- as.numeric(result[1])
hospital_address$lat[i] <- as.numeric(result[2])
}
ui <- fluidPage(
leafletOutput("mymap")
)
server <- function(input, output, session) {
output$mymap <- renderLeaflet({
leaflet() %>%addTiles() %>%
addMarkers(lat=hospital_address$lat,lng=hospital_address$lon,popup=as.character(hospital_address$State)
)
})
}
shinyApp(ui,server)
flaggedError <- c()
for(i in 1:nrow(hospital_address)) {
if(hospital_address$lon[i] <= right && hospital_address$lon[i] >= left
&& hospital_address$lat[i] <= top && hospital_address$lat[i] >= bottom) {
flaggedError <- c(flaggedError)
}else{
flaggedError <- c(flaggedError,i)
}
}
ui <- fluidPage(
leafletOutput("mymap")
)
server <- function(input, output, session) {
output$mymap <- renderLeaflet({
leaflet(hospital_address[flaggedError,]) %>%addTiles() %>%
addMarkers(lat=~lat,lng=~lon,popup=as.character(~State)
)
})
}
shinyApp(ui,server)
top  <- 72 # north lat
left <- -160 # west long
right <- -66.9513812 # east long
bottom <-  18 # south lat
flaggedError <- c()
for(i in 1:nrow(hospital_address)) {
if(hospital_address$lon[i] <= right && hospital_address$lon[i] >= left
&& hospital_address$lat[i] <= top && hospital_address$lat[i] >= bottom) {
flaggedError <- c(flaggedError)
}else{
flaggedError <- c(flaggedError,i)
}
}
server <- function(input, output, session) {
output$mymap <- renderLeaflet({
leaflet(hospital_address[flaggedError,]) %>%addTiles() %>%
addMarkers(lat=~lat,lng=~lon,popup=as.character(~Hospital.Name)
)
})
}
shinyApp(ui,server)
print(hospital_address[flaggedError,])
hospital_address[253,c("lon","lat")] <- as.numeric(geocode(paste(hospital_address$City[i],"Massachusetts USA"), output = "latlon", source = "dsk"))
hospital_address[977,c("lon","lat")] <- as.numeric(geocode(paste(hospital_address$City[i],"Massachusetts USA"), output = "latlon", source = "dsk"))
hospital_address[253,c("lon","lat")] <- as.numeric(geocode(paste(hospital_address$City[253],"Massachusetts USA"), output = "latlon", source = "dsk"))
hospital_address[977,c("lon","lat")] <- as.numeric(geocode(paste(hospital_address$City[977],"Massachusetts USA"), output = "latlon", source = "dsk"))
ui <- fluidPage(
leafletOutput("mymap")
)
server <- function(input, output, session) {
output$mymap <- renderLeaflet({
leaflet(hospital_address[flaggedError,]) %>%addTiles() %>%
addMarkers(lat=~lat,lng=~lon,popup=as.character(~Hospital.Name)
)
})
}
shinyApp(ui,server)
server <- function(input, output, session) {
output$mymap <- renderLeaflet({
leaflet(hospital_address) %>%addTiles() %>%
addMarkers(lat=~lat,lng=~lon,popup=as.character(hospital_address$State)
)
})
}
shinyApp(ui,server)
View(hospital_info)
hospital <- hospital_info %>% left_join(hospital_address)
write.csv(hospital, "hospital_2016.csv", row.names=FALSE)
write.csv(hospital_address,"hospital_address.csv",row.names = FALSE)
setwd("~/Documents/GitHub/Fall2018-Project2-sec2_proj2_grp7/app")
runApp()
