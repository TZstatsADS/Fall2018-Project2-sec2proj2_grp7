# # Input
# r.state <- reactive(input$r.state)
# r.drg <- reactive(input$r.drg)
# r.care <- reactive(input$r.care)
# r.score <- reactive(input$r.score)
# #r.cost <- reactive(input$r.cost)
#
# # Filter data by state and DRG
# f1 <- reactive({
#   if (r.state() == "Select") {f1 <- hospital_info}
#   else {hospital_info %>% filter(State == r.state())}
# })
#
# f2 <- reactive({
#   if (r.drg() == "Select") {f2 <- f1}
#   else {f1 %>% filter(DRG.Definition == r.drg())}
# })
#
# # filter by cost
#
# # Define care weight by input
# o.c.w <- c(1, 1, 1, 1, 1, 1, 1)
# name <- c("Selected","Mortality","Safety of Care","Readmission Rate","Patient Experience",
#           "Effectiveness of Care","Timeliness of Care","Efficient Use of Medical Imaging")
# c.weight <- reactive({
#   if (r.care() == "Select") {o.c.w
#   } else {o.c.w[which(name == r.care())] <- 2; o.c.w}
# })
#
# # Apply getscore function to every row of the selected data
# score.res <- reactive(apply(f2, 1, getscore, care.w = c.weight))
#
# # Filter by min score
# score.res <- reactive(score.res)
# r.order <- reactive(order(score.res, decreasing = T))
# #f2$rank <- reactive(floor(frankv(score.res, order = -1, ties.method = "min")))
# f2$pay.with.medi <- f2$Average.Total.Payments - f2$Average.Medicare.Payments
#
# # Data table output
# output$r.df <- renderDataTable({
#   final.d <- f2[
#     r.order,
#     c("Hospital Name", "Address", "City", "State", "Zipcode",
#                            "Phone Number", "Average Total Payments", "pay.with.medi")]
#   final.d}, options = list(orderClasses = TRUE,
#                            iDisplayLength = 5, lengthMenu = c(5, 10, 15, 20)
#   ))
#
}
shinyApp(ui, server)
server <- function(input, output) {
set_key("AIzaSyDdlgehS7a81ffnUqrpnHdJASMQPZsRdpU")
long <- state.center$x[which(input$r.state==state.abb)]
lat <- state.center$y[which(input$r.state==state.abb)]
output$map <- renderGoogle_map({
google_map(search_box = TRUE,location = c(long,lat),
zoom = 10)
})
# # load data
# # Haven't been tested; could be replaced by read.csv()
# #load("./hospital\ info.csv")
# #hospital_info <- read.csv("../data/hospital_info.csv")
# # Input
# r.state <- reactive(input$r.state)
# r.drg <- reactive(input$r.drg)
# r.care <- reactive(input$r.care)
# r.score <- reactive(input$r.score)
# #r.cost <- reactive(input$r.cost)
#
# # Filter data by state and DRG
# f1 <- reactive({
#   if (r.state() == "Select") {f1 <- hospital_info}
#   else {hospital_info %>% filter(State == r.state())}
# })
#
# f2 <- reactive({
#   if (r.drg() == "Select") {f2 <- f1}
#   else {f1 %>% filter(DRG.Definition == r.drg())}
# })
#
# # filter by cost
#
# # Define care weight by input
# o.c.w <- c(1, 1, 1, 1, 1, 1, 1)
# name <- c("Selected","Mortality","Safety of Care","Readmission Rate","Patient Experience",
#           "Effectiveness of Care","Timeliness of Care","Efficient Use of Medical Imaging")
# c.weight <- reactive({
#   if (r.care() == "Select") {o.c.w
#   } else {o.c.w[which(name == r.care())] <- 2; o.c.w}
# })
#
# # Apply getscore function to every row of the selected data
# score.res <- reactive(apply(f2, 1, getscore, care.w = c.weight))
#
# # Filter by min score
# score.res <- reactive(score.res)
# r.order <- reactive(order(score.res, decreasing = T))
# #f2$rank <- reactive(floor(frankv(score.res, order = -1, ties.method = "min")))
# f2$pay.with.medi <- f2$Average.Total.Payments - f2$Average.Medicare.Payments
#
# # Data table output
# output$r.df <- renderDataTable({
#   final.d <- f2[
#     r.order,
#     c("Hospital Name", "Address", "City", "State", "Zipcode",
#                            "Phone Number", "Average Total Payments", "pay.with.medi")]
#   final.d}, options = list(orderClasses = TRUE,
#                            iDisplayLength = 5, lengthMenu = c(5, 10, 15, 20)
#   ))
#
}
shinyApp(ui, server)
long <- state.center$x[which("NY"==state.abb)]
server <- function(input, output) {
set_key("AIzaSyDdlgehS7a81ffnUqrpnHdJASMQPZsRdpU")
long <- state.center$x[which("NY"==state.abb)]
lat <- state.center$y[which("NY"==state.abb)]
output$map <- renderGoogle_map({
google_map(search_box = TRUE,location = c(long,lat),
zoom = 10)
})
# # load data
# # Haven't been tested; could be replaced by read.csv()
# #load("./hospital\ info.csv")
# #hospital_info <- read.csv("../data/hospital_info.csv")
# # Input
# r.state <- reactive(input$r.state)
# r.drg <- reactive(input$r.drg)
# r.care <- reactive(input$r.care)
# r.score <- reactive(input$r.score)
# #r.cost <- reactive(input$r.cost)
#
# # Filter data by state and DRG
# f1 <- reactive({
#   if (r.state() == "Select") {f1 <- hospital_info}
#   else {hospital_info %>% filter(State == r.state())}
# })
#
# f2 <- reactive({
#   if (r.drg() == "Select") {f2 <- f1}
#   else {f1 %>% filter(DRG.Definition == r.drg())}
# })
#
# # filter by cost
#
# # Define care weight by input
# o.c.w <- c(1, 1, 1, 1, 1, 1, 1)
# name <- c("Selected","Mortality","Safety of Care","Readmission Rate","Patient Experience",
#           "Effectiveness of Care","Timeliness of Care","Efficient Use of Medical Imaging")
# c.weight <- reactive({
#   if (r.care() == "Select") {o.c.w
#   } else {o.c.w[which(name == r.care())] <- 2; o.c.w}
# })
#
# # Apply getscore function to every row of the selected data
# score.res <- reactive(apply(f2, 1, getscore, care.w = c.weight))
#
# # Filter by min score
# score.res <- reactive(score.res)
# r.order <- reactive(order(score.res, decreasing = T))
# #f2$rank <- reactive(floor(frankv(score.res, order = -1, ties.method = "min")))
# f2$pay.with.medi <- f2$Average.Total.Payments - f2$Average.Medicare.Payments
#
# # Data table output
# output$r.df <- renderDataTable({
#   final.d <- f2[
#     r.order,
#     c("Hospital Name", "Address", "City", "State", "Zipcode",
#                            "Phone Number", "Average Total Payments", "pay.with.medi")]
#   final.d}, options = list(orderClasses = TRUE,
#                            iDisplayLength = 5, lengthMenu = c(5, 10, 15, 20)
#   ))
#
}
shinyApp(ui, server)
server <- function(input, output) {
set_key("AIzaSyDdlgehS7a81ffnUqrpnHdJASMQPZsRdpU")
long <- state.center$x[which("NY"==state.abb)]
lat <- state.center$y[which("NY"==state.abb)]
output$map <- renderGoogle_map({
google_map(search_box = TRUE,location = c(lat,long),
zoom = 10)
})
# # load data
# # Haven't been tested; could be replaced by read.csv()
# #load("./hospital\ info.csv")
# #hospital_info <- read.csv("../data/hospital_info.csv")
# # Input
# r.state <- reactive(input$r.state)
# r.drg <- reactive(input$r.drg)
# r.care <- reactive(input$r.care)
# r.score <- reactive(input$r.score)
# #r.cost <- reactive(input$r.cost)
#
# # Filter data by state and DRG
# f1 <- reactive({
#   if (r.state() == "Select") {f1 <- hospital_info}
#   else {hospital_info %>% filter(State == r.state())}
# })
#
# f2 <- reactive({
#   if (r.drg() == "Select") {f2 <- f1}
#   else {f1 %>% filter(DRG.Definition == r.drg())}
# })
#
# # filter by cost
#
# # Define care weight by input
# o.c.w <- c(1, 1, 1, 1, 1, 1, 1)
# name <- c("Selected","Mortality","Safety of Care","Readmission Rate","Patient Experience",
#           "Effectiveness of Care","Timeliness of Care","Efficient Use of Medical Imaging")
# c.weight <- reactive({
#   if (r.care() == "Select") {o.c.w
#   } else {o.c.w[which(name == r.care())] <- 2; o.c.w}
# })
#
# # Apply getscore function to every row of the selected data
# score.res <- reactive(apply(f2, 1, getscore, care.w = c.weight))
#
# # Filter by min score
# score.res <- reactive(score.res)
# r.order <- reactive(order(score.res, decreasing = T))
# #f2$rank <- reactive(floor(frankv(score.res, order = -1, ties.method = "min")))
# f2$pay.with.medi <- f2$Average.Total.Payments - f2$Average.Medicare.Payments
#
# # Data table output
# output$r.df <- renderDataTable({
#   final.d <- f2[
#     r.order,
#     c("Hospital Name", "Address", "City", "State", "Zipcode",
#                            "Phone Number", "Average Total Payments", "pay.with.medi")]
#   final.d}, options = list(orderClasses = TRUE,
#                            iDisplayLength = 5, lengthMenu = c(5, 10, 15, 20)
#   ))
#
}
shinyApp(ui, server)
server <- function(input, output) {
set_key("AIzaSyDdlgehS7a81ffnUqrpnHdJASMQPZsRdpU")
long <- state.center$x[which("NY"==state.abb)]
lat <- state.center$y[which("NY"==state.abb)]
output$map <- renderGoogle_map({
google_map(search_box = TRUE,location = c(lat,long),
zoom = 0)
})
# # load data
# # Haven't been tested; could be replaced by read.csv()
# #load("./hospital\ info.csv")
# #hospital_info <- read.csv("../data/hospital_info.csv")
# # Input
# r.state <- reactive(input$r.state)
# r.drg <- reactive(input$r.drg)
# r.care <- reactive(input$r.care)
# r.score <- reactive(input$r.score)
# #r.cost <- reactive(input$r.cost)
#
# # Filter data by state and DRG
# f1 <- reactive({
#   if (r.state() == "Select") {f1 <- hospital_info}
#   else {hospital_info %>% filter(State == r.state())}
# })
#
# f2 <- reactive({
#   if (r.drg() == "Select") {f2 <- f1}
#   else {f1 %>% filter(DRG.Definition == r.drg())}
# })
#
# # filter by cost
#
# # Define care weight by input
# o.c.w <- c(1, 1, 1, 1, 1, 1, 1)
# name <- c("Selected","Mortality","Safety of Care","Readmission Rate","Patient Experience",
#           "Effectiveness of Care","Timeliness of Care","Efficient Use of Medical Imaging")
# c.weight <- reactive({
#   if (r.care() == "Select") {o.c.w
#   } else {o.c.w[which(name == r.care())] <- 2; o.c.w}
# })
#
# # Apply getscore function to every row of the selected data
# score.res <- reactive(apply(f2, 1, getscore, care.w = c.weight))
#
# # Filter by min score
# score.res <- reactive(score.res)
# r.order <- reactive(order(score.res, decreasing = T))
# #f2$rank <- reactive(floor(frankv(score.res, order = -1, ties.method = "min")))
# f2$pay.with.medi <- f2$Average.Total.Payments - f2$Average.Medicare.Payments
#
# # Data table output
# output$r.df <- renderDataTable({
#   final.d <- f2[
#     r.order,
#     c("Hospital Name", "Address", "City", "State", "Zipcode",
#                            "Phone Number", "Average Total Payments", "pay.with.medi")]
#   final.d}, options = list(orderClasses = TRUE,
#                            iDisplayLength = 5, lengthMenu = c(5, 10, 15, 20)
#   ))
#
}
shinyApp(ui, server)
server <- function(input, output) {
set_key("AIzaSyDdlgehS7a81ffnUqrpnHdJASMQPZsRdpU")
long <- state.center$x[which("NY"==state.abb)]
lat <- state.center$y[which("NY"==state.abb)]
output$map <- renderGoogle_map({
google_map(search_box = TRUE,location = c(lat,long),
zoom = 5)
})
# # load data
# # Haven't been tested; could be replaced by read.csv()
# #load("./hospital\ info.csv")
# #hospital_info <- read.csv("../data/hospital_info.csv")
# # Input
# r.state <- reactive(input$r.state)
# r.drg <- reactive(input$r.drg)
# r.care <- reactive(input$r.care)
# r.score <- reactive(input$r.score)
# #r.cost <- reactive(input$r.cost)
#
# # Filter data by state and DRG
# f1 <- reactive({
#   if (r.state() == "Select") {f1 <- hospital_info}
#   else {hospital_info %>% filter(State == r.state())}
# })
#
# f2 <- reactive({
#   if (r.drg() == "Select") {f2 <- f1}
#   else {f1 %>% filter(DRG.Definition == r.drg())}
# })
#
# # filter by cost
#
# # Define care weight by input
# o.c.w <- c(1, 1, 1, 1, 1, 1, 1)
# name <- c("Selected","Mortality","Safety of Care","Readmission Rate","Patient Experience",
#           "Effectiveness of Care","Timeliness of Care","Efficient Use of Medical Imaging")
# c.weight <- reactive({
#   if (r.care() == "Select") {o.c.w
#   } else {o.c.w[which(name == r.care())] <- 2; o.c.w}
# })
#
# # Apply getscore function to every row of the selected data
# score.res <- reactive(apply(f2, 1, getscore, care.w = c.weight))
#
# # Filter by min score
# score.res <- reactive(score.res)
# r.order <- reactive(order(score.res, decreasing = T))
# #f2$rank <- reactive(floor(frankv(score.res, order = -1, ties.method = "min")))
# f2$pay.with.medi <- f2$Average.Total.Payments - f2$Average.Medicare.Payments
#
# # Data table output
# output$r.df <- renderDataTable({
#   final.d <- f2[
#     r.order,
#     c("Hospital Name", "Address", "City", "State", "Zipcode",
#                            "Phone Number", "Average Total Payments", "pay.with.medi")]
#   final.d}, options = list(orderClasses = TRUE,
#                            iDisplayLength = 5, lengthMenu = c(5, 10, 15, 20)
#   ))
#
}
shinyApp(ui, server)
server <- function(input, output) {
set_key("AIzaSyDdlgehS7a81ffnUqrpnHdJASMQPZsRdpU")
long <- state.center$x[which("NY"==state.abb)]
lat <- state.center$y[which("NY"==state.abb)]
output$map <- renderGoogle_map({
google_map(search_box = TRUE,location = c(lat,long),
zoom = 7)
})
# # load data
# # Haven't been tested; could be replaced by read.csv()
# #load("./hospital\ info.csv")
# #hospital_info <- read.csv("../data/hospital_info.csv")
# # Input
# r.state <- reactive(input$r.state)
# r.drg <- reactive(input$r.drg)
# r.care <- reactive(input$r.care)
# r.score <- reactive(input$r.score)
# #r.cost <- reactive(input$r.cost)
#
# # Filter data by state and DRG
# f1 <- reactive({
#   if (r.state() == "Select") {f1 <- hospital_info}
#   else {hospital_info %>% filter(State == r.state())}
# })
#
# f2 <- reactive({
#   if (r.drg() == "Select") {f2 <- f1}
#   else {f1 %>% filter(DRG.Definition == r.drg())}
# })
#
# # filter by cost
#
# # Define care weight by input
# o.c.w <- c(1, 1, 1, 1, 1, 1, 1)
# name <- c("Selected","Mortality","Safety of Care","Readmission Rate","Patient Experience",
#           "Effectiveness of Care","Timeliness of Care","Efficient Use of Medical Imaging")
# c.weight <- reactive({
#   if (r.care() == "Select") {o.c.w
#   } else {o.c.w[which(name == r.care())] <- 2; o.c.w}
# })
#
# # Apply getscore function to every row of the selected data
# score.res <- reactive(apply(f2, 1, getscore, care.w = c.weight))
#
# # Filter by min score
# score.res <- reactive(score.res)
# r.order <- reactive(order(score.res, decreasing = T))
# #f2$rank <- reactive(floor(frankv(score.res, order = -1, ties.method = "min")))
# f2$pay.with.medi <- f2$Average.Total.Payments - f2$Average.Medicare.Payments
#
# # Data table output
# output$r.df <- renderDataTable({
#   final.d <- f2[
#     r.order,
#     c("Hospital Name", "Address", "City", "State", "Zipcode",
#                            "Phone Number", "Average Total Payments", "pay.with.medi")]
#   final.d}, options = list(orderClasses = TRUE,
#                            iDisplayLength = 5, lengthMenu = c(5, 10, 15, 20)
#   ))
#
}
shinyApp(ui, server)
library(car)
library(MASS)
library(glmnet)
data("birthwt")
race.decode <- function(x){
return(ifelse(x!=1,1,0))
}
birthwt$race <- sapply(birthwt$race,race.decode)
fit1 <- lm(bwt~age+lwt+race+smoke+ptl+ht+ui+ftv,data=birthwt)
summary(fit1)
ev <- eigen(cor(fit1$model))
# Eigenvalues of correlation matrix of X
ev$values
max(ev$values)/min(ev$values)
# Evaluate Collinearity
vif(fit1) # variance inflation factors
lambdas <- 10^seq(3, -3, by = -.1)
X <- as.matrix(birthwt[,2:9])
Y <- as.matrix(birthwt[,10])
cv_ridge_fit <- cv.glmnet(X, Y, alpha = 0, lambda = lambdas)
plot(cv_ridge_fit)
ev <- eigen(cor(X))
ev$values
max(ev$values)/min(ev$values)
fit2 <- cv_ridge_fit$glmnet.fit
summary(fit2)
opt_lambda <- cv_ridge_fit$lambda.min
Y_predicted_ridge <- predict(fit2, s = opt_lambda, newx = X)
ridge.coef <- predict(fit2, type = "coefficients", s = opt_lambda)[1:8,]
print(ridge.coef)
# RSS
rss_ridge <- sum((Y-Y_predicted_ridge)^2)
rss_ols <- sum(fit1$residuals^2)
# R squared
R_sq_ols <- summary(fit1)$r.squared
R_sq_ridge <- 1 - rss_ridge/sum((Y-mean(Y))^2)
# Adjust R squared
adj_r_sq_ols <- summary(fit1)$adj.r.squared
adj_coef <- (nrow(Y)-1)/(nrow(Y)-ncol(X)-1)
adj_r_sq_ridge <- 1-adj_coef*rss_ridge/sum((Y-mean(Y))^2)
list(RSS=c(rss_ols,rss_ridge),Rsquared=c(R_sq_ols,R_sq_ridge),AdjustedRsquared=c(adj_r_sq_ols,adj_r_sq_ridge))
help("table")
help("matrix")
matrix(c(rss_ols,rss_ridge,R_sq_ols,
R_sq_ridge,adj_r_sq_ols,adj_r_sq_ridge),
nrow = 3, dimnames =
list(rows=c("RSS","R squared","Adjusted R squared"),
cols=c("OLS","Ridge")))
matrix(c(rss_ols,rss_ridge,R_sq_ols,
R_sq_ridge,adj_r_sq_ols,adj_r_sq_ridge),
nrow = 3, byrow=T, dimnames =
list(rows=c("RSS","R squared","Adjusted R squared"),
cols=c("OLS","Ridge")))
print(matrix(c(rss_ols,rss_ridge,R_sq_ols,
R_sq_ridge,adj_r_sq_ols,adj_r_sq_ridge),
nrow = 3, byrow=T, dimnames =
list(rows=c("RSS","R squared","Adjusted R squared"),
cols=c("OLS","Ridge"))))
cv_lasso_fit <- cv.glmnet(X, Y, alpha = 1, lambda = lambdas)
plot(cv_lasso_fit)
fit3 <- cv_lasso_fit$glmnet.fit
plot(fit3)
summary(fit3)
plot(fit2)
fit3 <- cv_lasso_fit$glmnet.fit
plot(fit3)
opt_lambda <- cv_lasso_fit$lambda.min
Y_predicted_lasso <- predict(fit3, s = opt_lambda, newx = X)
lasso.coef  <- predict(fit3, type = 'coefficients', s = opt_lambda)[1:8,]
lasso.coef
rss_lasso <- sum((Y-Y_predicted_lasso)^2)
rss_lasso
R_sq_lasso <- 1 - rss_lasso/sum((Y-mean(Y))^2)
R_sq_lasso
fit4 <- stepAIC(fit1, direction = "forward", trace = FALSE)
summary(fit4)
fit4 <- stepAIC(fit1, direction = "backward", trace = FALSE)
summary(fit4)
View(X)
R_sq_stepwise <- summary(fit4)$r.squared
rss_stepwise <- sum(fit4$residuals^2)
print(matrix(c(rss_lasso,rss_stepwise,R_sq_lasso,
R_sq_stepwise),nrow = 2, byrow=T, dimnames =
list(rows=c("RSS","R squared"),
cols=c("Lasso","Stepwise(backward)"))))
ev <- eigen(cor(fit1$model))
# Eigenvalues of correlation matrix of X
# condition number >30 indicate multicollinearity
max(ev$values)/min(ev$values)
